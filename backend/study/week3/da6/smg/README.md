# Python 클래스 상속과 오버라이딩 학습 가이드

## 📚 학습 목표

이 프로젝트는 Python의 **클래스 상속**과 **메서드 오버라이딩** 개념을 게임 캐릭터 시스템을 통해 학습하는 것을 목표로 합니다.

## 🎯 주요 학습 내용

### 1. 클래스 상속 (Inheritance)
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 개념
- 코드 재사용성과 확장성 향상
- `class 자식클래스(부모클래스):` 문법 사용

### 2. 메서드 오버라이딩 (Method Overriding)
- 부모 클래스의 메서드를 자식 클래스에서 재정의하는 기법
- 같은 메서드명으로 다른 동작 구현
- 다형성(Polymorphism) 구현의 기초

### 3. super() 함수
- 부모 클래스의 메서드나 생성자 호출
- `super().__init__()`: 부모 클래스 생성자 호출
- `super().메서드명()`: 부모 클래스 메서드 호출

### 4. 다형성 (Polymorphism)
- 하나의 인터페이스로 여러 타입의 객체를 다루는 능력
- 같은 메서드 호출이 객체 타입에 따라 다르게 동작

### 5. 타입 확인
- `isinstance(객체, 클래스)`: 객체가 특정 클래스의 인스턴스인지 확인

## 🏗️ 클래스 구조

### Character (부모 클래스)
**역할**: 모든 게임 캐릭터의 공통 속성과 기능을 정의

**속성**:
- `name`: 캐릭터 이름
- `hp`: 현재 체력
- `max_hp`: 최대 체력
- `mp`: 현재 마나
- `max_mp`: 최대 마나
- `level`: 레벨

**메서드**:
- `__init__(name, hp=100, mp=50)`: 생성자
- `attack()`: 기본 공격 (오버라이딩 대상)
- `take_damage(damage)`: 데미지 받기
- `get_status()`: 상태 조회
- `introduce()`: 자기소개 (오버라이딩 대상)

### Warrior (전사 클래스)
**역할**: Character를 상속받은 근접 전투 특화 클래스

**고유 속성**:
- `strength`: 힘 (20)
- `armor`: 방어력 (10)

**스탯 특징**: HP 높음(150), MP 낮음(30)

**오버라이딩 메서드**:
- `attack()`: 검 공격으로 변경
- `introduce()`: 전사 특화 소개

**고유 메서드**:
- `shield_block()`: 방패 막기 스킬

### Mage (마법사 클래스)
**역할**: Character를 상속받은 마법 공격 특화 클래스

**고유 속성**:
- `intelligence`: 지능 (25)
- `spell_power`: 마법력 (18)

**스탯 특징**: HP 낮음(80), MP 높음(150)

**오버라이딩 메서드**:
- `attack()`: 마법 공격으로 변경 (MP 소모)
- `introduce()`: 마법사 특화 소개

**고유 메서드**:
- `magic_heal(target)`: 치료 마법 스킬

### Archer (궁수 클래스)
**역할**: Character를 상속받은 원거리 공격 특화 클래스

**고유 속성**:
- `dexterity`: 민첩성 (22)
- `accuracy`: 정확도 (18)

**스탯 특징**: 균형잡힌 스탯 HP(120), MP(80)

**오버라이딩 메서드**:
- `attack()`: 화살 공격으로 변경
- `introduce()`: 궁수 특화 소개

**고유 메서드**:
- `power_shot()`: 강력한 화살 스킬

### SuperWarrior (슈퍼 전사 클래스)
**역할**: Warrior를 상속받아 super() 사용법을 학습하기 위한 클래스

**고유 속성**:
- `super_strength`: 초강력 (50)

**특징**: 기존 전사의 모든 능력 + 추가 강화

**오버라이딩 메서드**:
- `attack()`: 부모의 attack() 결과에 추가 데미지 더함

**학습 포인트**:
- `super().__init__()`: 부모 생성자 호출
- `super().attack()`: 부모 메서드 호출 후 확장

## 🔧 주요 함수

### test_inheritance_and_overriding()
**목적**: 상속과 오버라이딩의 전체적인 동작을 단계별로 테스트

**테스트 순서**:
1. 각 클래스 객체 생성
2. 부모 클래스 메서드 상속 확인
3. 오버라이딩된 `introduce()` 메서드 테스트
4. 오버라이딩된 `attack()` 메서드 테스트
5. 각 클래스의 고유 스킬 테스트
6. `isinstance()`로 타입 확인
7. 다형성 테스트 (리스트에서 공통 메서드 호출)
8. 간단한 전투 시뮬레이션

### demonstrate_super()
**목적**: `super()` 함수의 사용법을 SuperWarrior 클래스를 통해 실습

**학습 내용**:
- `super().__init__()`: 부모 생성자 호출
- `super().메서드명()`: 부모 메서드 호출 후 추가 기능 구현
- 상속 체인에서의 메서드 확장 방법

## 💡 핵심 개념 정리

### 상속의 장점
```python
# 코드 재사용: 공통 기능을 부모 클래스에 한 번만 정의
class Character:  # 공통 기능 정의
    def get_status(self): ...
    
class Warrior(Character):  # 상속받아서 재사용
    pass  # get_status() 자동으로 사용 가능
```

### 오버라이딩의 활용
```python
# 같은 메서드명, 다른 구현
def attack(self):  # 부모 클래스
    return "기본 공격"
    
def attack(self):  # 자식 클래스에서 오버라이딩
    return "검 공격"  # 다른 동작으로 재정의
```

### super()의 사용
```python
def __init__(self, name):
    super().__init__(name, hp=150, mp=30)  # 부모 생성자 호출
    self.strength = 20  # 추가 속성

def attack(self):
    parent_result = super().attack()  # 부모 메서드 호출
    return f"{parent_result} + 추가 공격!"  # 확장
```

### 다형성의 구현
```python
characters = [Warrior("아서"), Mage("간달프"), Archer("레골라스")]

for char in characters:
    print(char.attack())  # 같은 메서드 호출
    # 하지만 각 객체의 타입에 따라 다른 결과
    # "검 공격", "마법 공격", "화살 공격"
```

## 🚀 실행 방법

```bash
python day6.py
```

## 📖 학습 순서 추천

1. **기본 개념 이해**: 상속, 오버라이딩, super() 개념 숙지
2. **코드 읽기**: 각 클래스의 구조와 메서드 파악
3. **실행 결과 분석**: 출력 결과를 통해 동작 원리 이해
4. **코드 수정 실험**: 새로운 캐릭터 클래스 추가해보기
5. **응용**: 다른 도메인에 상속 개념 적용해보기

## 🎓 확장 학습 아이디어

- **새 캐릭터 클래스 추가**: Healer, Assassin 등
- **추상 클래스 활용**: ABC 모듈 사용
- **다중 상속**: Mixin 패턴 적용
- **프로퍼티 활용**: @property 데코레이터 사용
- **특별 메서드**: `__str__`, `__repr__` 오버라이딩

## 📝 주의사항

- Python에서는 모든 클래스가 암묵적으로 `object`를 상속받음
- 메서드 오버라이딩 시 메서드명과 매개변수가 정확히 일치해야 함
- `super()`는 메서드 해결 순서(MRO)를 따름
- 상속은 "is-a" 관계일 때 사용하는 것이 적절함